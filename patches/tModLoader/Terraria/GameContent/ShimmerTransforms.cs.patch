--- src/TerrariaNetCore/Terraria/GameContent/ShimmerTransforms.cs
+++ src/tModLoader/Terraria/GameContent/ShimmerTransforms.cs
@@ -1,4 +_,9 @@
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Xna.Framework;
 using Terraria.ID;
+using Terraria.ModLoader;
 
 namespace Terraria.GameContent;
 
@@ -12,6 +_,7 @@
 
 	public static int GetDecraftingRecipeIndex(int type)
 	{
+		/*
 		int num = ItemID.Sets.IsCrafted[type];
 		if (num < 0)
 			return -1;
@@ -23,6 +_,14 @@
 			return ItemID.Sets.IsCraftedCorruption[type];
 
 		return num;
+		*/
+
+		foreach (int recipeIndex in ItemID.Sets.CraftingRecipeIndices[type]) {
+			if (RecipeLoader.DecraftAvailable(Main.recipe[recipeIndex]))
+				return recipeIndex;
+		}
+
+		return -1;
 	}
 
 	public static bool IsItemTransformLocked(int type)
@@ -37,6 +_,9 @@
 		if (!NPC.downedGolemBoss && RecipeSets.PostGolem[decraftingRecipeIndex])
 			return true;
 
+		if (!RecipeLoader.DecraftAvailable(Main.recipe[decraftingRecipeIndex]))
+			return true;
+
 		return false;
 	}
 
@@ -44,5 +_,314 @@
 	{
 		RecipeSets.PostSkeletron = Utils.MapArray(Main.recipe, (Recipe r) => r.ContainsIngredient(154));
 		RecipeSets.PostGolem = Utils.MapArray(Main.recipe, (Recipe r) => r.ContainsIngredient(1101));
+	}
+}
+
+// TML: #AdvancedShimmerTransformations
+public sealed class ShimmerTransformation
+{
+	internal static List<ShimmerTransformation[]> AdvancedShimmerSets = new();
+
+	public ShimmerTransformation(NPC npc)
+	{
+		transformationType = 0;
+		TargetID = npc.type;
+	}
+
+	public ShimmerTransformation(Item item)
+	{
+		transformationType = 1;
+		TargetID = item.type;
+	}
+
+	public ShimmerTransformation()
+	{
+	}
+
+	/// <summary>
+	/// Every condition must be true for the transformation to occur
+	/// </summary>
+	public List<Condition> Conditions { get; private set; } = new();
+
+	/// <summary>
+	/// The entities that the transformation produces.
+	/// </summary>
+	public List<ShimmerResult> Results = new();
+
+	public bool TreatAsVanilla { get; private set; }
+
+	/// <summary>
+	/// 0 for NPC, 1 for Item
+	/// </summary>
+	private int transformationType = -1;
+
+	public Type TransformationType {
+		get => transformationType switch {
+			0 => typeof(NPC),
+			1 => typeof(Item),
+			_ => null
+		};
+	}
+
+	public int TargetID = -1;
+
+	/// <summary>
+	/// Adds a condition to <see cref="Conditions"/>
+	/// </summary>
+	/// <param name="condition"> The condition to be added </param>
+	public ShimmerTransformation AddCondition(Condition condition)
+	{
+		Conditions.Add(condition);
+		return this;
+	}
+
+	/// <summary>
+	/// Adds a result to <see cref="Results"/>
+	/// </summary>
+	/// <param name="result"> The result to be added </param>
+	public ShimmerTransformation AddResult(ShimmerResult result)
+	{
+		Results.Add(result);
+		return this;
+	}
+
+	/// <summary>
+	/// Makes this shimmer operation use the vanilla code for shimmering, restricts shimmer operations to the following constraints:
+	/// <list type="bullet">
+	/// <item/> Requires the type of the transformation origin to be set via <see cref="SetAsNPCTransformation"/> or <see cref="SetAsItemTransformation"/>
+	/// <item/> NPCs can only transform into either one npc or one item
+	/// <item/> Items can only transform into items of unrestricted count
+	/// </list>
+	/// If these are not met <see cref="Register(int)"/> will throw an error
+	/// </summary>
+	public ShimmerTransformation SetTreatAsVanilla()
+	{
+		TreatAsVanilla = true;
+		return this;
+	}
+
+	public ShimmerTransformation SetAsNPCTransformation()
+	{
+		transformationType = 0;
+		return this;
+	}
+
+	public ShimmerTransformation SetAsItemTransformation()
+	{
+		transformationType = 1;
+		return this;
+	}
+
+	/// <summary>
+	///	Called in addition to conditions to check if the entity shimmers
+	/// </summary>
+	/// <param name="origin"> The entity that was shimmered, either an <see cref="Item"/> or an <see cref="NPC"/></param>
+	public delegate bool CanShimmerCallBack(Entity origin);
+
+	internal CanShimmerCallBack CanShimmerCallBacks;
+
+	public ShimmerTransformation AddCanShimmerCallBack(CanShimmerCallBack callBack)
+	{
+		CanShimmerCallBacks += callBack;
+		return this;
+	}
+
+	/// <summary>
+	/// By default just checks the conditions, when overriding in a derived class remember that you will have to check base.CanShimmer in order to preserve this behavior
+	/// </summary>
+	/// <returns>True if the entity should proceed to transform</returns>
+	public bool CanShimmer(Entity entity) => Conditions.All((condition) => condition.IsMet()) && (CanShimmerCallBacks?.Invoke(entity) ?? true);
+
+	/// <summary>
+	///	Called when the entity shimmers
+	/// </summary>
+	/// <param name="spawnedNPCs"> A list of the spawned NPCs </param>
+	/// <param name="spawnedItems"> A list of the spawned items </param>
+	/// <param name="origin"> The entity that was shimmered, either an <see cref="Item"/> or an <see cref="NPC"/></param>
+	public delegate void OnShimmerCallBack(Entity origin, List<NPC> spawnedNPCs, List<Item> spawnedItems); // TODO: Make this able to be changed non destructively?
+
+	internal OnShimmerCallBack OnShimmerCallBacks;
+
+	public ShimmerTransformation AddOnShimmerCallBack(OnShimmerCallBack callBack)
+	{
+		OnShimmerCallBacks += callBack;
+		return this;
+	}
+
+	public ShimmerTransformation Register(int registerFor)
+	{
+		TargetID = registerFor;
+		return Register();
+	}
+
+	public ShimmerTransformation Register()
+	{
+		if (TreatAsVanilla) {
+			switch (transformationType) {
+				case 0:
+					if (Results.Count != 1)
+						throw new InvalidOperationException("Using TreatAsVannila with an NPC requires there to be exactly 1 result");
+					if (Results[0].Count != 1)
+						throw new InvalidOperationException("Using TreatAsVannila with an NPC requires the result to have a count of exactly 1");
+					if (Results[0].ResultType == ShimmerResultType.Custom)
+						throw new InvalidOperationException("Using TreatAsVannila with an NPC requires its result not be Custom");
+					break;
+
+				case 1:
+					if (Results.Any(result => result.ResultType != ShimmerResultType.Item))
+						throw new InvalidOperationException("Using TreatAsVannila with an Item requires all results have a type of Item");
+					break;
+
+				default:
+					throw new InvalidOperationException("Using TreatAsVannila requires the type of the transformation origin to be set via SetAsNPCTransformation() or SetAsItemTransformation()");
+			};
+		}
+
+		if (transformationType == 0) {
+			if (NPCID.Sets.ShimmerAdvancedTransformIndex[TargetID] >= 0) {
+				AdvancedShimmerSets[NPCID.Sets.ShimmerAdvancedTransformIndex[TargetID]] = AdvancedShimmerSets[NPCID.Sets.ShimmerAdvancedTransformIndex[TargetID]].Append(this).ToArray();
+			}
+			else {
+				AdvancedShimmerSets.Add(new ShimmerTransformation[] { this });
+				NPCID.Sets.ShimmerAdvancedTransformIndex[TargetID] = AdvancedShimmerSets.Count - 1;
+			}
+		}
+		else if (transformationType == 1) {
+			if (ItemID.Sets.ShimmerAdvancedTransformIndex[TargetID] >= 0) {
+				AdvancedShimmerSets[ItemID.Sets.ShimmerAdvancedTransformIndex[TargetID]] = AdvancedShimmerSets[ItemID.Sets.ShimmerAdvancedTransformIndex[TargetID]].Append(this).ToArray();
+			}
+			else {
+				AdvancedShimmerSets.Add(new ShimmerTransformation[] { this });
+				ItemID.Sets.ShimmerAdvancedTransformIndex[TargetID] = AdvancedShimmerSets.Count - 1;
+			}
+		}
+
+		return this;
+	}
+}
+
+/// <summary>
+/// Value used by <see cref="ShimmerResult"/> to identify what type of entity to spawn. <br/>
+/// The <see cref="Custom"/> value simply sets the shimmer as successful, spawns nothing, for if you desire entirely custom behavior to be defined in <see cref="ShimmerTransformation{Entity}.OnShimmer(List{NPC}, List{Item})"/> but do not want to include the item or NPC spawn that would usually stop a fall through
+/// </summary>
+public enum ShimmerResultType
+{
+	NPC,
+	Item,
+	Custom,
+}
+
+/// <summary>
+/// A record representing an entity to spawn during a shimmer transformation
+/// </summary>
+/// <param name="ResultType"> The type of entity to spawn, NPC or Item </param>
+/// <param name="EntityID"> The type of the entity to spawn </param>
+/// <param name="Count"> The number of this entity to spawn, if an item it will spawn in a stack </param>
+public sealed record ShimmerResult(ShimmerResultType ResultType, int EntityID, int Count);
+
+public static class AdvancedShimmerTransformationHelper
+{
+	/// <summary>
+	/// The advanced shimmer logic, this generic method calls either the <see cref="NPC"/> or <see cref="Item"/> overloads depending on the type of <paramref name="entity"/>. <br/>
+	/// - This method assumes that <see cref="NPCID.Sets.ShimmerAdvancedTransformIndex"/> has a valid value for this NPC
+	/// </summary>
+	/// <param name="entity"> the <see cref="Entity"/> to shimmer </param>
+	/// <returns> true if the shimmer was successful </returns>
+	public static bool AdvancedShimmer(Entity entity)
+	{
+		if (typeof(Entity) == typeof(NPC))
+			return AdvancedShimmer(entity as NPC);
+		if (typeof(Entity) == typeof(Item))
+			return AdvancedShimmer(entity as Item);
+		throw new NotImplementedException("Currently only supports shimmer events on NPCs and Items");
+	}
+
+	public static bool AdvancedShimmer(NPC npc)
+	{
+		if (NPCID.Sets.ShimmerAdvancedTransformIndex[npc.type] < 0)
+			return false;
+		bool shimmerSuccess = false; // Because conditions are checked, this is here so we can continue onto other shimmer events when they fall through
+		int advancedShimmerIndex = NPCID.Sets.ShimmerAdvancedTransformIndex[npc.type];
+		foreach (ShimmerTransformation transformation in ShimmerTransformation.AdvancedShimmerSets[advancedShimmerIndex]) { // Loops possible transformations
+			if (transformation.CanShimmer(npc)) { // Checks conditions
+				List<NPC> spawnedNPCs = new();
+				List<Item> spawnedItems = new();
+				foreach (ShimmerResult shimmerResult in transformation.Results) { // Loop each shimmerResult
+					switch (shimmerResult.ResultType) { // could easily add in support for spawning projectiles, didn't currently because the use cases seem pretty low
+						case ShimmerResultType.Item: { // spawn item code copied from vanilla
+							int num = Item.NewItem(npc.GetItemSource_Misc(8), (int)npc.position.X, (int)npc.position.Y, npc.width, npc.height, shimmerResult.EntityID);
+							Main.item[num].stack = shimmerResult.Count;
+							Main.item[num].shimmerTime = 1f;
+							Main.item[num].shimmered = true;
+							Main.item[num].shimmerWet = true;
+							Main.item[num].wet = true;
+							Main.item[num].velocity *= 0.1f;
+							Main.item[num].playerIndexTheItemIsReservedFor = Main.myPlayer;
+							NetMessage.SendData(145, -1, -1, null, num, 1f);// net sync spawning the item
+
+							spawnedItems.Add(Main.item[num]);
+							break;
+						}
+
+						case ShimmerResultType.NPC: {
+							for (int i = 0; i < shimmerResult.Count; i++) { // Loop spawn NPCs, will more than likely always be only one, but for the sake of completeness this is here
+								if (Main.netMode != NetmodeID.MultiplayerClient) { // Else use the custom stuff and avoid spawning on multiplayer
+									NPC newNPC = NPC.NewNPCDirect(npc.GetSource_Misc("Shimmer"), (int)npc.position.X, (int)npc.position.Y, shimmerResult.EntityID); //Should cause net update stuff
+
+									//syncing up some values that vanilla intentionally sets after SetDefaults()
+									newNPC.extraValue = npc.extraValue;
+									newNPC.CopyInteractions(npc);
+									newNPC.SpawnedFromStatue = npc.SpawnedFromStatue;
+									newNPC.spriteDirection = npc.spriteDirection;
+									newNPC.Center = npc.Center + new Vector2(25f * ((1 - shimmerResult.Count) / 2 + i), 0); //Vanilla does not do centering like this, but otherwise multiple NPCs stack
+									newNPC.velocity = npc.velocity;
+									newNPC.shimmerTransparency = npc.shimmerTransparency;
+
+									if (npc.value == 0f)
+										newNPC.value = 0f;
+									for (int j = 0; j < NPC.maxBuffs; j++) {
+										newNPC.buffType[j] = npc.buffType[j];
+										newNPC.buffTime[j] = npc.buffTime[j];
+									}
+
+									spawnedNPCs.Add(newNPC);
+									newNPC.TargetClosest();
+								}
+							}
+
+							break;
+						}
+
+						case ShimmerResultType.Custom: {
+							break;
+						}
+					}
+					shimmerSuccess = true; // Inside the shimmer success loops so if it's empty for some reason, we still roll to the next
+				}
+
+				if (shimmerSuccess) { // If CanShimmer returns true and spawns something, delete the npc and return
+					transformation.OnShimmerCallBacks?.Invoke(npc, spawnedNPCs, spawnedItems);
+
+					if (Main.netMode == 0)
+						Item.ShimmerEffect(npc.Center);
+					else
+						NetMessage.SendData(146, -1, -1, null, 0, (int)npc.Center.X, (int)npc.Center.Y); //Shimmer effect and coinluck
+
+					npc.active = false; // despawn this NPC
+					if (Main.netMode == 2) {
+						npc.netSkip = -1;
+						npc.life = 0;
+						NetMessage.SendData(23, -1, -1, null, npc.whoAmI);
+					}
+					return true;
+				} // else continue to other shimmer opportunities
+			}
+		}
+		return false;
+	}
+
+	public static bool AdvancedShimmer(Item item)
+	{
+		throw new NotImplementedException();
 	}
 }
