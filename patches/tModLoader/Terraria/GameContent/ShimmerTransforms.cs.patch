--- src/TerrariaNetCore/Terraria/GameContent/ShimmerTransforms.cs
+++ src/tModLoader/Terraria/GameContent/ShimmerTransforms.cs
@@ -1,4 +_,10 @@
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Xna.Framework;
+using Terraria.DataStructures;
 using Terraria.ID;
+using Terraria.ModLoader;
 
 namespace Terraria.GameContent;
 
@@ -12,6 +_,7 @@
 
 	public static int GetDecraftingRecipeIndex(int type)
 	{
+		/*
 		int num = ItemID.Sets.IsCrafted[type];
 		if (num < 0)
 			return -1;
@@ -23,6 +_,14 @@
 			return ItemID.Sets.IsCraftedCorruption[type];
 
 		return num;
+		*/
+
+		foreach (int recipeIndex in ItemID.Sets.CraftingRecipeIndices[type]) {
+			if (RecipeLoader.DecraftAvailable(Main.recipe[recipeIndex]))
+				return recipeIndex;
+		}
+
+		return -1;
 	}
 
 	public static bool IsItemTransformLocked(int type)
@@ -37,6 +_,9 @@
 		if (!NPC.downedGolemBoss && RecipeSets.PostGolem[decraftingRecipeIndex])
 			return true;
 
+		if (!RecipeLoader.DecraftAvailable(Main.recipe[decraftingRecipeIndex]))
+			return true;
+
 		return false;
 	}
 
@@ -46,3 +_,338 @@
 		RecipeSets.PostGolem = Utils.MapArray(Main.recipe, (Recipe r) => r.ContainsIngredient(1101));
 	}
 }
+
+// TML: #AdvancedShimmerTransformations
+public sealed class ShimmerTransformation
+{
+	public static List<ShimmerTransformation[]> AdvancedShimmerSets { get; private set; } = new();
+
+	public ShimmerTransformation(NPC npc) : this(new ShimmerSource(ShimmerTypeID.NPC, npc.type))
+	{
+	}
+
+	public ShimmerTransformation(Item item) : this(new ShimmerSource(ShimmerTypeID.Item, item.type))
+	{
+	}
+
+	public ShimmerTransformation() : this(new ShimmerSource(ShimmerTypeID.Null, -1))
+	{
+	}
+
+	public ShimmerTransformation(ShimmerSource shimmerSource)
+	{
+		Source = shimmerSource;
+	}
+
+	/// <summary>
+	/// Every condition must be true for the transformation to occur
+	/// </summary>
+	public List<Condition> Conditions { get; private set; } = new();
+
+	/// <summary>
+	/// The entities that the transformation produces.
+	/// </summary>
+	public List<ShimmerResult> Results { get; private set; } = new();
+
+	public ShimmerSource Source { get; private set; }
+	public bool TreatAsVanilla { get; private set; }
+
+	/// <summary>
+	/// Disallows transformation if a transformation result includes either a bone or a solar tablet fragment, when skeletron or golem are undefeated
+	/// </summary>
+	public bool CheckVanillaConstraints { get; private set; } = true;
+
+	/// <summary>
+	/// Adds a condition to <see cref="Conditions"/>
+	/// </summary>
+	/// <param name="condition"> The condition to be added </param>
+	public ShimmerTransformation AddCondition(Condition condition)
+	{
+		Conditions.Add(condition);
+		return this;
+	}
+
+	/// <summary>
+	/// Adds a result to <see cref="Results"/>
+	/// </summary>
+	/// <param name="result"> The result to be added </param>
+	public ShimmerTransformation AddResult(ShimmerResult result)
+	{
+		Results.Add(result);
+		return this;
+	}
+
+	/// <summary>
+	/// Makes this shimmer operation use the vanilla code for shimmering, restricts shimmer operations to the following constraints:
+	/// <list type="bullet">
+	/// <item/> Requires the type of the transformation origin to be set via <see cref="SetAsNPCTransformation"/> or <see cref="SetAsItemTransformation"/>, this is already done if instantiated from an instance of <see cref="ModNPC"/> or <see cref="ModItem"/>
+	/// <item/> NPCs can only transform into either one npc or one item
+	/// <item/> Items may transform into any combination of other items but can only transform into single npcs and will use release logic to do so
+	/// </list>
+	/// If these are not met <see cref="Register()"/> will throw an error
+	/// </summary>
+	public ShimmerTransformation SetTreatAsVanilla()
+	{
+		TreatAsVanilla = true;
+		return this;
+	}
+
+	public ShimmerTransformation SetAsNPCTransformation()
+	{
+		Source = new(ShimmerTypeID.NPC, Source.EntityID);
+		return this;
+	}
+
+	public ShimmerTransformation SetAsItemTransformation()
+	{
+		Source = new(ShimmerTypeID.Item, Source.EntityID);
+		return this;
+	}
+
+	/// <summary>
+	///	Called in addition to conditions to check if the entity shimmers
+	/// </summary>
+	/// <param name="origin"> The entity that was shimmered, either an <see cref="Item"/> or an <see cref="NPC"/></param>
+	public delegate bool CanShimmerCallBack(Entity origin);
+
+	internal CanShimmerCallBack CanShimmerCallBacks;
+
+	public ShimmerTransformation AddCanShimmerCallBack(CanShimmerCallBack callBack)
+	{
+		CanShimmerCallBacks += callBack;
+		return this;
+	}
+
+	/// <summary>
+	/// By default just checks the conditions, when overriding in a derived class remember that you will have to check base.CanShimmer in order to preserve this behavior
+	/// </summary>
+	/// <returns>True if the entity should proceed to transform</returns>
+	public bool CanShimmer(Entity entity) => Conditions.All((condition) => condition.IsMet()) && (CanShimmerCallBacks?.Invoke(entity) ?? true) && (!CheckVanillaConstraints || !Results.Any((result) => result.ResultType == ShimmerTypeID.Item && (result.EntityID == 154 || result.EntityID == 1101)));
+
+	/// <summary>
+	///	Called when the entity shimmers
+	/// </summary>
+	/// <param name="spawnedEntities"> A list of the spawned Entities </param>
+	/// <param name="origin"> The entity that was shimmered, either an <see cref="Item"/> or an <see cref="NPC"/></param>
+	public delegate void OnShimmerCallBack(Entity origin, List<Entity> spawnedEntities);
+
+	internal OnShimmerCallBack OnShimmerCallBacks;
+
+	public ShimmerTransformation AddOnShimmerCallBack(OnShimmerCallBack callBack)
+	{
+		OnShimmerCallBacks += callBack;
+		return this;
+	}
+
+	public void Register()
+	{
+		if (TreatAsVanilla) {
+			switch (Source.SourceType) {
+				case ShimmerTypeID.NPC:
+					if (Results.Count != 1)
+						throw new InvalidOperationException("Using TreatAsVannila with an NPC requires there to be exactly 1 result");
+					if (Results[0].Count != 1)
+						throw new InvalidOperationException("Using TreatAsVannila with an NPC requires the result to have a count of exactly 1");
+					if (Results[0].ResultType == ShimmerTypeID.Custom)
+						throw new InvalidOperationException("Using TreatAsVannila with an NPC requires its result not be Custom");
+					break;
+
+				case ShimmerTypeID.Item:
+					if (Results.Any(result => result.ResultType != ShimmerTypeID.Item))
+						throw new InvalidOperationException("Using TreatAsVannila with an Item requires all results have a type of Item");
+					break;
+
+				default:
+					throw new InvalidOperationException("Using TreatAsVannila requires the type of the transformation origin to be set via SetAsNPCTransformation() or SetAsItemTransformation()");
+			};
+		}
+
+		if (ShimmerAdvancedTransformIndex()[Source.EntityID] >= 0) {
+			AdvancedShimmerSets[ShimmerAdvancedTransformIndex()[Source.EntityID]] = AdvancedShimmerSets[ShimmerAdvancedTransformIndex()[Source.EntityID]].Append(this).ToArray();
+		}
+		else {
+			AdvancedShimmerSets.Add(new ShimmerTransformation[] { this });
+			ShimmerAdvancedTransformIndex()[Source.EntityID] = AdvancedShimmerSets.Count - 1;
+		}
+	}
+
+	private int[] ShimmerAdvancedTransformIndex() => ShimmerAdvancedTransformIndex(Source.SourceType);
+
+	private static int[] ShimmerAdvancedTransformIndex(ShimmerTypeID shimmerTypeID)
+	{
+		return shimmerTypeID switch {
+			ShimmerTypeID.NPC => NPCID.Sets.ShimmerAdvancedTransformIndex,
+			ShimmerTypeID.Item => ItemID.Sets.ShimmerAdvancedTransformIndex,
+			_ => throw new NotImplementedException()
+		};
+	}
+
+	/// <summary>
+	/// The advanced shimmer logic, this generic method calls either the <see cref="NPC"/> or <see cref="Item"/> overloads depending on the type of <paramref name="entity"/>. <br/>
+	/// - This method assumes that <see cref="NPCID.Sets.ShimmerAdvancedTransformIndex"/> has a valid value for this NPC
+	/// </summary>
+	/// <param name="entity"> the <see cref="Entity"/> to shimmer </param>
+	/// <returns> true if the shimmer was successful </returns>
+	public static bool AdvancedShimmer(Entity entity)
+	{
+		if (typeof(Entity) == typeof(NPC))
+			return AdvancedShimmer(entity as NPC);
+		if (typeof(Entity) == typeof(Item))
+			return AdvancedShimmer(entity as Item);
+		throw new NotImplementedException("Currently only supports shimmer events on NPCs and Items");
+	}
+
+	public static bool AdvancedShimmer(NPC npc)
+	{
+		if (NPCID.Sets.ShimmerAdvancedTransformIndex[npc.type] < 0)
+			return false;
+		ShimmerData shimmerData = new(npc);
+		int advancedShimmerIndex = NPCID.Sets.ShimmerAdvancedTransformIndex[npc.type];
+
+		if (AdvancedShimmer(shimmerData, AdvancedShimmerSets[advancedShimmerIndex])) {
+			npc.active = false; // despawn this NPC
+			if (Main.netMode == 2) {
+				npc.netSkip = -1;
+				npc.life = 0;
+				NetMessage.SendData(23, -1, -1, null, npc.whoAmI);
+			}
+			return true;
+		}
+		return false;
+	}
+
+	public static bool AdvancedShimmer(Item item)
+	{
+		if (NPCID.Sets.ShimmerAdvancedTransformIndex[item.type] < 0)
+			return false;
+		ShimmerData shimmerData = new(item);
+		int advancedShimmerIndex = NPCID.Sets.ShimmerAdvancedTransformIndex[item.type];
+
+		if (AdvancedShimmer(shimmerData, AdvancedShimmerSets[advancedShimmerIndex])) {
+			throw new NotImplementedException();
+			return true;
+		}
+		return false;
+	}
+
+	private static bool AdvancedShimmer(ShimmerData shimmerData, ShimmerTransformation[] shimmerTransformations)
+	{
+		foreach (ShimmerTransformation transformation in shimmerTransformations) { // Loops possible transformations
+			if (transformation.CanShimmer(shimmerData.Source) && transformation.Results.Count > 0) { // Checks conditions and callback in CanShimmer
+				List<Entity> spawnedEntities = new();
+
+				for (int resultIndex = 0; resultIndex < transformation.Results.Count; resultIndex++)
+					SpawnShimmerResult(shimmerData, transformation.Results[resultIndex], resultIndex);
+
+				transformation.OnShimmerCallBacks?.Invoke(shimmerData.Source, spawnedEntities);
+
+				if (Main.netMode == 0)
+					Item.ShimmerEffect(shimmerData.Center);
+				else
+					NetMessage.SendData(146, -1, -1, null, 0, (int)shimmerData.Center.X, (int)shimmerData.Center.Y); //Shimmer effect net side
+
+				return true;
+			}
+		}
+		return false;
+	}
+
+	private static void SpawnShimmerResult(ShimmerData shimmerData, ShimmerResult shimmerResult, int resultIndex)
+	{
+		switch (shimmerResult.ResultType) { // could easily add in support for spawning projectiles, didn't currently because the use cases seem pretty low
+			case ShimmerTypeID.Item: { // spawn item code copied from vanilla
+				int num = Item.NewItem(shimmerData.EntitySource, (int)shimmerData.Position.X, (int)shimmerData.Position.Y, shimmerData.Width, shimmerData.Height, shimmerResult.EntityID);
+				Main.item[num].stack = shimmerResult.Count;
+				Main.item[num].shimmerTime = 1f;
+				Main.item[num].shimmered = true;
+				Main.item[num].shimmerWet = true;
+				Main.item[num].wet = true;
+				Main.item[num].velocity *= 0.1f;
+				Main.item[num].playerIndexTheItemIsReservedFor = Main.myPlayer;
+				NetMessage.SendData(145, -1, -1, null, num, 1f);// net sync spawning the item
+
+				//spawnedItems.Add(Main.item[num]); TODO fix with delegate
+				break;
+			}
+
+			case ShimmerTypeID.NPC: {
+				for (int i = 0; i < shimmerResult.Count; i++) { // Loop spawn NPCs, will more than likely always be only one, but for the sake of completeness this is here
+					if (Main.netMode != NetmodeID.MultiplayerClient) { // Else use the custom stuff and avoid spawning on multiplayer
+						NPC newNPC = NPC.NewNPCDirect(shimmerData.EntitySource, (int)shimmerData.Position.X, (int)shimmerData.Position.Y, shimmerResult.EntityID); //Should cause net update stuff
+
+						//syncing up some values that vanilla intentionally sets after SetDefaults() is NPC transformations, mostly self explanatory
+						if (shimmerData.Source is NPC && shimmerResult.KeepVanillaNPCTransformationValues) {
+							newNPC.extraValue = (shimmerData.Source as NPC).extraValue;
+							newNPC.CopyInteractions((shimmerData.Source as NPC));
+							newNPC.SpawnedFromStatue = (shimmerData.Source as NPC).SpawnedFromStatue;
+							newNPC.spriteDirection = (shimmerData.Source as NPC).spriteDirection;
+							newNPC.shimmerTransparency = (shimmerData.Source as NPC).shimmerTransparency;
+
+							if ((shimmerData.Source as NPC).value == 0f)
+								newNPC.value = 0f;
+							for (int j = 0; j < NPC.maxBuffs; j++) {
+								newNPC.buffType[j] = (shimmerData.Source as NPC).buffType[j];
+								newNPC.buffTime[j] = (shimmerData.Source as NPC).buffTime[j];
+							}
+						}
+
+						newNPC.Center = shimmerData.Center + new Vector2(25f * ((1 - shimmerResult.Count) / 2 + i), 0); //Vanilla does not do centering like this, but otherwise multiple NPCs stack
+						newNPC.velocity = shimmerData.Velocity;
+
+						//spawnedNPCs.Add(newNPC); fix with delegate
+						newNPC.TargetClosest();
+					}
+				}
+
+				break;
+			}
+
+			case ShimmerTypeID.Custom: {
+				break;
+			}
+
+			case ShimmerTypeID.Null: {
+				throw new ArgumentException("The value for shimmerResult.ResultType should not be ShimmerTypeID.Null at this point, if behavior is being manually added please use ShimmerTypeID.Custom", nameof(shimmerResult));
+			}
+		}
+	}
+
+	private record ShimmerData(IEntitySource EntitySource, Vector2 Position, Vector2 Velocity, int Width, int Height, Entity Source)
+	{
+		public ShimmerData(Entity entity) : this(entity.GetSource_Misc(context: ItemSourceID.ToContextString(itemSourceId)), entity.position, entity.velocity, entity.width, entity.height, entity)
+		{ }
+		public Vector2 Center => Position + new Vector2(Width, Height) / 2;
+	}
+}
+
+/// <summary>
+/// Value used by <see cref="ShimmerResult"/> to identify what type of entity to spawn. <br/>
+/// The <see cref="Custom"/> value simply sets the shimmer as successful, spawns nothing, for if you desire entirely custom behavior to be defined in <see cref="ShimmerTransformation{Entity}.OnShimmer"/> but do not want to include the item or NPC spawn that would usually stop a fall through
+/// </summary>
+public enum ShimmerTypeID
+{
+	NPC,
+	Item,
+	Custom,
+	Null,
+}
+
+/// <summary>
+/// A record representing the information to spawn and entity during a shimmer transformation
+/// </summary>
+/// <param name="ResultType"> The type of entity to spawn </param>
+/// <param name="EntityID"> The type of the entity to spawn </param>
+/// <param name="Count"> The number of this entity to spawn, if an item it will spawn in a stack </param>
+/// <param name="KeepVanillaNPCTransformationValues"> Makes spawned NPCs duplicate  </param>
+public sealed record ShimmerResult(ShimmerTypeID ResultType, int EntityID, int Count, bool KeepVanillaNPCTransformationValues)
+{
+	public ShimmerResult(ShimmerTypeID ResultType, int EntityID, int Count) : this(ResultType, EntityID, Count, true)
+	{ }
+}
+
+/// <summary>
+/// A record representing the type information of an entity that will transform in shimmer
+/// </summary>
+/// <param name="SourceType"> The type of entity to shimmer </param>
+/// <param name="EntityID"> The type of the entity to shimmer </param>
+public sealed record ShimmerSource(ShimmerTypeID SourceType, int EntityID);
